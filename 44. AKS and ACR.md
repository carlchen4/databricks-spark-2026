下面给你一条**从开发者本地 → 生产 AKS**的“完整标准流程”（Python ML 模型 + FastAPI 推理服务），包含你提到的：**Docker image → push ACR → Helm/kubectl 部署**。我会按真实团队的分工/步骤写。

---

## 0) 你要交付的东西（开发者产物）

项目目录通常长这样：

```
ml-inference-service/
├─ app.py                  # FastAPI 推理入口
├─ model/                  # 模型文件(可选) 例如 model.pkl
├─ requirements.txt        # 依赖
├─ Dockerfile              # 镜像配方
└─ k8s/                    # 部署文件（Helm 或 YAML）
   ├─ chart/               # Helm chart（可选）
   └─ deployment.yaml      # kubectl YAML（可选）
```

---

## 1) 开发阶段（本地跑通）

### 1.1 本地虚拟环境 + 运行

```bash
python -m venv venv
source venv/Scripts/activate   # Git Bash
pip install -r requirements.txt
python -m uvicorn app:app --reload
```

### 1.2 本地验证

* Swagger: `http://127.0.0.1:8000/docs`
* curl / Postman 测试 `/predict`

输出确认 OK 后才进入下一步。

---

## 2) 打包成容器镜像（Dockerfile → Image）

### 2.1 Dockerfile（生产推荐写法：requirements）

```dockerfile
FROM python:3.11-slim
WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app.py ./app.py
# 如果模型随镜像
COPY model/ ./model/

EXPOSE 8000
CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 2.2 本地 build 并跑一下（强烈建议）

```bash
docker build -t fakeapi:1.0.0 .
docker run -p 8000:8000 fakeapi:1.0.0
```

验证 `http://127.0.0.1:8000/docs` OK。

---

## 3) 推到 ACR（镜像仓库）

> 生产里 ACR 通常是共享的（企业订阅），权限由平台团队管。

### 3.1 登录 ACR

```bash
az login
az acr login -n <ACR_NAME>
```

### 3.2 镜像打 tag（必须带 registry 前缀）

```bash
docker tag fakeapi:1.0.0 <ACR_NAME>.azurecr.io/fakeapi:1.0.0
```

### 3.3 push

```bash
docker push <ACR_NAME>.azurecr.io/fakeapi:1.0.0
```

✅ 替代：如果你不想本地 Docker build，也可以用：

```bash
az acr build -r <ACR_NAME> -t fakeapi:1.0.0 .
```

---

## 4) 部署到 AKS（两种主流方式：kubectl YAML 或 Helm）

---

# 方式 A：kubectl + YAML（简单直接）

### 4A.1 deployment.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fakeapi
spec:
  replicas: 2
  selector:
    matchLabels:
      app: fakeapi
  template:
    metadata:
      labels:
        app: fakeapi
    spec:
      containers:
        - name: fakeapi
          image: <ACR_NAME>.azurecr.io/fakeapi:1.0.0
          ports:
            - containerPort: 8000
          readinessProbe:
            httpGet: { path: "/", port: 8000 }
            initialDelaySeconds: 5
          livenessProbe:
            httpGet: { path: "/", port: 8000 }
            initialDelaySeconds: 15
---
apiVersion: v1
kind: Service
metadata:
  name: fakeapi-svc
spec:
  selector:
    app: fakeapi
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 8000
```

### 4A.2 部署

```bash
az aks get-credentials -g <RG> -n <AKS_NAME>
kubectl apply -f deployment.yaml
kubectl get pods
kubectl get svc fakeapi-svc
```

---

# 方式 B：Helm Chart（团队/多环境更常用）

### 4B.1 Helm 的思想

把镜像 tag、replicas、资源、环境变量放到 `values.yaml`，部署时替换：

```bash
helm upgrade --install fakeapi ./chart -f values-prod.yaml
```

### 4B.2 values-prod.yaml 里你会改这些

* `image.repository`
* `image.tag`
* `replicaCount`
* `resources`
* `env`（比如 MODEL_URI、LOG_LEVEL）

**Helm 的好处：**dev/test/prod 只改 values，不用拷贝一堆 YAML。

---

## 5) 生产必备：让 AKS 能拉 ACR 镜像（权限）

最常见做法（推荐）：

```bash
az aks update -g <RG> -n <AKS_NAME> --attach-acr <ACR_NAME>
```

不然你会看到 Pod `ImagePullBackOff`。

---

## 6) 发布升级流程（真实团队节奏）

**每次上线本质就是：换镜像 tag**：

1. 改代码
2. build 新镜像 `fakeapi:1.0.1`
3. push 到 ACR
4. 更新部署引用的 tag

   * kubectl：改 YAML image tag → `kubectl apply`
   * Helm：改 `values-prod.yaml` → `helm upgrade`
5. 观察 pods / logs / metrics

---

## 7) 真实银行里通常会加的“门禁”

* CI/CD：GitHub Actions / Azure DevOps 自动 build+push+deploy
* 安全扫描：镜像漏洞扫描
* 审批：prod deploy 需要审批
* Secrets：Vault（不要写死在镜像里）
* Ingress/APIM：不要直接暴露 LoadBalancer（生产常用域名 + HTTPS + 限流）

---

## 一句话总结

开发者把 Python ML 模型做成 FastAPI 服务 → **Dockerfile 打包成镜像** → **推到 ACR** → 在 AKS 用 **kubectl YAML 或 Helm** 引用这个镜像来跑服务（多副本、健康检查、对外暴露）。

---

如果你想我把这条流程变成“你们公司常用的更标准版”，我可以再给一个 **CI/CD pipeline 模板**（Azure DevOps 或 GitHub Actions），一步到位：commit → 自动 build → push ACR → helm upgrade AKS。你们更像用 ADO 还是 GitHub Actions？
